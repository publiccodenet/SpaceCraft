//------------------------------------------------------------------------------
// <file_path>Unity/CraftSpace/Assets/Scripts/Schemas/SchemaGeneratedObject.cs</file_path>
// <namespace>CraftSpace</namespace>
// <assembly>Assembly-CSharp</assembly>
//
// IMPORTANT: This is the BASE CLASS for all schema-generated objects.
// It is NOT auto-generated and should be carefully maintained.
// It handles JSON serialization/deserialization and extra fields.
//
// THIS IS THE SHARED FOUNDATION FOR ALL SCHEMA CLASSES.
// Put common functionality here rather than duplicating in Item.cs or Collection.cs.
// When making changes, verify against the schema generator to ensure compatibility.
//
// ALWAYS:
// 1. Update the schema generator when adding/changing base functionality
// 2. Regenerate schema classes when base class changes
// 3. Keep the API consistent with what the generator expects
// 4. Fix errors in the schema generator FIRST before modifying this class
//
// CRITICAL WORKFLOW FOR SCHEMA CHANGES:
// - DO NOT MODIFY the generated schema classes (*.Schema.cs files)
// - If generated files have errors, fix SchemaGenerator.cs FIRST
// - IF you need to add custom functionality, add it to extension classes (Item.cs, Collection.cs)
// - KEEP those extension classes as thin as possible
// - PUT shared functionality here in SchemaGeneratedObject.cs
//
// EXTRAFIELDS IMPLEMENTATION:
// - The 'extraFields' property is ONLY defined in this C# base class
// - It is NOT part of the JSON schema or Zod schema definitions
// - Its purpose is to capture and preserve any properties from JSON that aren't
//   defined in the schema
// - This allows for backward compatibility with changing data sources
// - It should be treated as an internal implementation detail
//------------------------------------------------------------------------------

using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;

/// <summary>
/// Base class for all schema-generated objects.
/// Handles JSON serialization/deserialization and extra fields.
/// This class provides the runtime framework for reflection-free JSON handling,
/// working in conjunction with the explicit code generated by SchemaGenerator.cs.
/// It avoids reliance on reflection-based features of JSON.NET that are incompatible
/// with IL2CPP/WebGL builds.
/// </summary>
public abstract class SchemaGeneratedObject : ScriptableObject
{
    [SerializeField] protected JObject extraFields = new JObject();
    
    /// <summary>
    /// Abstract property for the unique identifier. Must be implemented by generated classes.
    /// </summary>
    public abstract string Id { get; set; }
    
    /// <summary>
    /// Import data from JSON string. Parses the JSON and then calls the generated
    /// ImportKnownProperties and the base ImportExtraFields for deserialization,
    /// avoiding reflection for user-defined types.
    /// </summary>
    public virtual void ImportFromJson(string json)
    {
        try
        {
            if (string.IsNullOrEmpty(json))
            {
                Debug.LogWarning($"[{GetType().Name}] Empty JSON string passed to ImportFromJson");
                return;
            }

            JObject data = null;
            try 
            {
                data = JObject.Parse(json);
            }
            catch (Exception parseEx)
            {
                Debug.LogError($"[{GetType().Name}] Failed to parse JSON: {parseEx.Message}");
                return; // Exit early if we can't parse the JSON
            }
            
            // Clear existing extra fields before import
            extraFields = new JObject();

            // --- Call abstract/virtual methods --- 
            try
            {
                ImportKnownProperties(data); // Populate derived class fields (including Id)
                ImportExtraFields(data); // Populate extra fields
            }
            catch (Exception ex)
            {
                Debug.LogError($"[{GetType().Name}] Error in ImportFromJson: {ex.Message}");
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"[{GetType().Name}] Error in ImportFromJson: {ex.Message}");
        }
    }
    
    /// <summary>
    /// Import data directly from pre-parsed JObject
    /// Avoids redundant string-to-JObject parsing
    /// </summary>
    public virtual void ImportFromJToken(JObject data)
    {
        try
        {
            if (data == null)
            {
                Debug.LogWarning($"[{GetType().Name}] Null JObject passed to ImportFromJToken");
                return;
            }
            
            // Clear existing extra fields before import
            extraFields = new JObject();
            
            try
            {
                ImportKnownProperties(data); // Populate derived class fields
                ImportExtraFields(data); // Populate extra fields
            }
            catch (Exception ex)
            {
                Debug.LogError($"[{GetType().Name}] Error in ImportFromJToken: {ex.Message}");
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"[{GetType().Name}] Error in ImportFromJToken: {ex.Message}");
        }
    }
    
    /// <summary>
    /// Import known properties from a JObject
    /// </summary>
    protected abstract void ImportKnownProperties(JObject json);
    
    /// <summary>
    /// Import extra fields from a JObject
    /// </summary>
    protected virtual void ImportExtraFields(JObject json)
    {
        try
        {
            if (json == null)
            {
                Debug.LogError($"[{GetType().Name}] ImportExtraFields called with null JObject");
                return;
            }
            
            extraFields = new JObject();
            
            foreach (var prop in json)
            {
                try
                {
                    string propertyName = prop.Key;
                    if (!HasDefinedProperty(propertyName))
                    {
                        extraFields[propertyName] = prop.Value;
                    }
                }
                catch (Exception propEx)
                {
                    Debug.LogError($"[{GetType().Name}] Error processing property {prop.Key}: {propEx.Message}");
                    // Continue with the next property
                }
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"[{GetType().Name}] Error in ImportExtraFields: {ex.Message}");
            // Don't rethrow - we want to gracefully recover
        }
    }
    
    /// <summary>
    /// Export to JSON string
    /// </summary>
    public virtual string ExportToJson(bool prettyPrint = true)
    {
        try
        {
            var json = new JObject();
            
            var knownProps = ExportKnownProperties();
            foreach (var prop in knownProps)
            {
                json[prop.Key] = prop.Value;
            }
            
            foreach (var prop in extraFields)
            {
                json[prop.Key] = prop.Value;
            }
            
            return json.ToString(prettyPrint ? Formatting.Indented : Formatting.None);
        }
        catch (Exception ex)
        {
            Debug.LogError($"[{GetType().Name}] Error in ExportToJson: {ex.Message}");
            throw;
        }
    }
    
    /// <summary>
    /// Export known properties to a JObject
    /// </summary>
    protected abstract JObject ExportKnownProperties();
    
    /// <summary>
    /// Check if a property is defined in the schema
    /// </summary>
    protected abstract bool HasDefinedProperty(string name);

    #region View Registration and Management

    [NonSerialized] private HashSet<object> registeredViews = new HashSet<object>();
    
    /// <summary>
    /// Register a view to receive updates from this model
    /// </summary>
    /// <param name="view">The view to register</param>
    public virtual void RegisterView(object view)
    {
        //if (enableDebug) {
        //    Debug.Log("[" + GetType().Name + "] Registered view: " + ((view == null) ? "null" : view.GetType().Name));
        //}

        registeredViews.Add(view);
    }
    
    /// <summary>
    /// Unregister a view from this model
    /// </summary>
    /// <param name="view">The view to unregister</param>
    public virtual void UnregisterView(object view)
    {
        try
        {
            if (view != null)
            {
                registeredViews.Remove(view);
                //if (enableDebug) {
                //    Debug.Log("[" + GetType().Name + "] Unregistered view: " + ((view == null) ? "null" : view.GetType().Name));
                //}
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"[{GetType().Name}] Error unregistering view: {ex.Message}");
        }
    }
    
    /// <summary>
    /// Get all registered views of a specific type
    /// </summary>
    /// <typeparam name="TView">The type of views to retrieve</typeparam>
    /// <returns>Collection of views that match the specified type</returns>
    protected IEnumerable<TView> GetViewsOfType<TView>()
    {
        foreach (var view in registeredViews)
        {
            if (view is TView typedView)
            {
                yield return typedView;
            }
        }
    }
    
    /// <summary>
    /// Notify all registered views of a specific type
    /// </summary>
    /// <typeparam name="TView">The type of views to notify</typeparam>
    /// <param name="notificationAction">The action to perform on each view</param>
    protected void NotifyViewsOfType<TView>(Action<TView> notificationAction)
    {
        try
        {
            int count = 0;
            foreach (var view in GetViewsOfType<TView>())
            {
                try
                {
                    notificationAction(view);
                    count++;
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[{GetType().Name}] Error notifying view: {ex.Message}");
                }
            }
            
            //if (enableDebug) {
            //    if (count > 0) {
            //        Debug.Log("[" + GetType().Name + "] Notified " + count + " views of type " + typeof(TView).Name);
            //    }
            //}
        }
        catch (Exception ex)
        {
            Debug.LogError($"[{GetType().Name}] Error in NotifyViewsOfType: {ex.Message}");
        }
    }

    #endregion
} 