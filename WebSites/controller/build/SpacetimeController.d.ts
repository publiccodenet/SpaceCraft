// Generated by dts-bundle-generator v9.5.1

// Generated by dts-bundle-generator v9.5.1
export type VDOMElement = {
	tag: string;
	props?: Record<string, any>;
	children?: Array<VDOMElement | null> | string;
};
export type IntegerNumeric = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32;
export type IntegerString = `${IntegerNumeric}`;
export type IntegerAny = IntegerNumeric | IntegerString;
export type Boolean$1 = boolean | "true" | "false";
export type Lang = "ab" | "aa" | "af" | "ak" | "sq" | "am" | "ar" | "an" | "hy" | "as" | "av" | "ae" | "ay" | "az" | "bm" | "ba" | "eu" | "be" | "bn" | "bh" | "bi" | "bs" | "br" | "bg" | "my" | "ca" | "ch" | "ce" | "ny" | "zh" | "zh-ans" | "zh-ant" | "cv" | "kw" | "co" | "cr" | "hr" | "cs" | "da" | "dv" | "nl" | "dz" | "en" | "eo" | "et" | "ee" | "fo" | "fj" | "fi" | "fr" | "ff" | "gl" | "gd" | "ka" | "de" | "el" | "kl" | "gn" | "gu" | "ht" | "ha" | "he" | "hz" | "hi" | "ho" | "hu" | "is" | "io" | "ig" | "id in" | "ia" | "ie" | "iu" | "ik" | "ga" | "it" | "ja" | "jv" | "kn" | "kr" | "ks" | "kk" | "km" | "ki" | "rw" | "rn" | "ky" | "kv" | "kg" | "ko" | "ku" | "kj" | "lo" | "la" | "lv" | "li" | "ln" | "lt" | "lu" | "lg" | "lb" | "gv" | "mk" | "mg" | "ms" | "ml" | "mt" | "mi" | "mr" | "mh" | "mo" | "mn" | "na" | "nv" | "ng" | "nd" | "ne" | "no" | "nb" | "nn" | "oc" | "oj" | "cu" | "or" | "om" | "os" | "pi" | "ps" | "fa" | "pl" | "pt" | "pa" | "qu" | "rm" | "ro" | "ru" | "se" | "sm" | "sg" | "sa" | "sr" | "sh" | "st" | "tn" | "sn" | "ii" | "sd" | "si" | "ss" | "sk" | "sl" | "so" | "nr" | "es" | "su" | "sw" | "sv" | "tl" | "ty" | "tg" | "ta" | "tt" | "te" | "th" | "bo" | "ti" | "to" | "ts" | "tr" | "tk" | "tw" | "ug" | "uk" | "ur" | "uz" | "ve" | "vi" | "vo" | "wa" | "cy" | "wo" | "fy" | "xh" | "yi" | "ji" | "yo" | "za" | "zu";
export type PropsWithUndefined<T> = {
	[K in keyof T]: T[K] | undefined;
};
export type AriaProps = PropsWithUndefined<{
	role?: "alert" | "alertdialog" | "application" | "article" | "banner" | "button" | "cell" | "checkbox" | "columnheader" | "combobox" | "complementary" | "contentinfo" | "definition" | "dialog" | "directory" | "document" | "feed" | "figure" | "form" | "grid" | "gridcell" | "group" | "heading" | "img" | "link" | "list" | "listbox" | "listitem" | "log" | "main" | "marquee" | "math" | "menu" | "menubar" | "menuitem" | "menuitemcheckbox" | "menuitemradio" | "navigation" | "none" | "note" | "option" | "presentation" | "progressbar" | "radio" | "radiogroup" | "region" | "row" | "rowgroup" | "rowheader" | "scrollbar" | "search" | "searchbox" | "separator" | "slider" | "spinbutton" | "status" | "switch" | "tab" | "table" | "tablist" | "tabpanel" | "term" | "textbox" | "timer" | "toolbar" | "tooltip" | "tree" | "treegrid" | "treeitem";
	ariaAtomic?: Boolean$1;
	ariaAutoComplete?: "inline" | "list" | "both" | "none";
	ariaBusy?: Boolean$1;
	ariaBrailleLabel?: string;
	ariaBrailleRoleDescription?: string;
	ariaChecked?: Boolean$1 | "mixed";
	ariaColCount?: IntegerAny;
	ariaColIndex?: IntegerAny;
	ariaColSpan?: IntegerAny;
	ariaCurrent?: Boolean$1 | "page" | "step" | "location" | "date" | "time" | "true" | "false";
	ariaDescription?: string;
	ariaDisabled?: Boolean$1;
	ariaExpanded?: Boolean$1 | "undefined";
	ariaHasPopup?: Boolean$1 | "menu" | "listbox" | "tree" | "grid" | "dialog";
	ariaHidden?: Boolean$1 | "undefined";
	ariaInvalid?: Boolean$1 | "grammar" | "spelling";
	ariaKeyShortcuts?: string;
	ariaLabel?: string;
	ariaLevel?: IntegerAny;
	ariaLive?: "assertive" | "polite" | "off";
	ariaModal?: Boolean$1;
	ariaMultiLine?: Boolean$1;
	ariaMultiSelectable?: Boolean$1;
	ariaOrientation?: "horizontal" | "vertical" | "undefined";
	ariaPlaceholder?: string;
	ariaPosInSet?: IntegerAny;
	ariaPressed?: Boolean$1 | "mixed" | "undefined";
	ariaReadOnly?: Boolean$1;
	ariaRequired?: Boolean$1;
	ariaRelevant?: "additions" | "all" | "removals" | "text";
	ariaRoleDescription?: string;
	ariaRowCount?: IntegerAny;
	ariaRowIndex?: IntegerAny;
	ariaRowSpan?: IntegerAny;
	ariaSelected?: Boolean$1 | "undefined";
	ariaSetSize?: IntegerAny;
	ariaSort?: "none" | "ascending" | "descending" | "other";
	ariaValueMax?: number | `${number}`;
	ariaValueMin?: number | `${number}`;
	ariaValueNow?: number | `${number}`;
	ariaValueText?: string;
	ariaColIndexText?: string;
	ariaRowIndexText?: string;
	ariaActiveDescendantElement?: HTMLElement;
	ariaControlsElements?: HTMLElement;
	ariaDescribedByElements?: HTMLElement;
	ariaDetailsElements?: HTMLElement;
	ariaErrorMessageElements?: HTMLElement;
	ariaFlowToElements?: HTMLElement;
	ariaLabelledByElements?: HTMLElement;
}>;
export type prefix<TKey, TPrefix extends string> = TKey extends string ? `${TPrefix}${TKey}` : never;
export type AnyEventHandler = ((event: CustomEvent<any>) => void) | ((event: PointerEvent) => void) | ((event: KeyboardEvent) => void) | ((event: MouseEvent) => void) | ((event: TouchEvent) => void) | ((event: WheelEvent) => void) | ((event: InputEvent) => void) | ((event: ClipboardEvent) => void) | ((event: DragEvent) => void) | ((event: FocusEvent) => void) | ((event: TransitionEvent) => void) | ((event: AnimationEvent) => void) | ((event: ErrorEvent) => void) | ((event: Event) => void);
export type NativeElementProps = AriaProps & PropsWithUndefined<{
	[key: prefix<string, "@">]: string | AnyEventHandler;
	title?: string;
	lang?: Lang;
	translate?: any;
	dir?: any;
	hidden?: any;
	inert?: any;
	accessKey?: any;
	draggable?: any;
	spellcheck?: boolean;
	autocapitalize?: any;
	contentEditable?: Boolean$1;
	enterKeyHint?: "enter" | "done" | "go" | "next" | "previous" | "search" | "send";
	inputMode?: "decimal" | "email" | "numeric" | "tel" | "search" | "url" | "text";
	virtualKeyboardPolicy?: "manual" | "auto";
	innerText?: string;
	outerText?: string;
	writingSuggestions?: Boolean$1;
	autofocus?: boolean;
	tabIndex?: IntegerAny | -1 | "-1";
	style?: Record<string, string>;
	id?: string;
	class?: string;
	innerHTML?: string;
	outerHTML?: string;
	scrollTop?: number;
	scrollLeft?: number;
	scrollWidth?: number;
	scrollHeight?: number;
	textContent?: string;
}>;
/**
 * Event listener types.
 */
export interface KeyboardEventListener {
	(event: KeyboardEvent): void;
}
export interface PointerEventListener {
	(event: PointerEvent): void;
}
export interface CustomEventListener {
	(event: CustomEvent): void;
}
export interface FocusEventListener {
	(event: FocusEvent): void;
}
export interface TouchEventListener {
	(event: TouchEvent): void;
}
export interface ChangeEventListener {
	(event: ChangeEvent): void;
}
export interface IoEventListener {
	(event: {
		detail: any;
		target: Node$1 | IoElement | EventTarget;
		path: Array<Node$1 | IoElement | EventTarget>;
	}): void;
}
export type AnyEventListener = EventListener | KeyboardEventListener | PointerEventListener | CustomEventListener | FocusEventListener | TouchEventListener | ChangeEventListener | IoEventListener | EventListenerOrEventListenerObject;
/**
 * Listener definition type.
 * The first item is a string (function name) or an event listener function.
 * The second item is an optional object of event listener options.
 */
export type ListenerDefinition = [
	string | AnyEventListener,
	AddEventListenerOptions?
];
/**
 * Loose listener definition type.
 * It can be a string (function name), an event AnyEventListener function or a ListenerDefinition array.
 */
export type ListenerDefinitionLoose = string | AnyEventListener | ListenerDefinition;
export type Listener = [
	AnyEventListener,
	AddEventListenerOptions?
];
export type Listeners = Record<string, Listener[]>;
declare class EventDispatcher {
	readonly node: Node$1 | IoElement | EventTarget;
	readonly nodeIsEventTarget: boolean;
	readonly protoListeners: Listeners;
	readonly propListeners: Listeners;
	readonly addedListeners: Listeners;
	/**
	 * Creates an instance of `EventDispatcher` for specified `Node` instance.
	 * It initializes `protoListeners` from `ProtoChain`.
	 * @param {Node | IoElement | EventTarget} node owner Node
	 */
	constructor(node: Node$1 | IoElement | EventTarget);
	/**
	 * Sets `protoListeners` specified as `get Listeners()` class definitions.
	 * Definitions from subclass replace the ones from parent class.
	 * @param {Node | IoElement} node owner Node
	 */
	setProtoListeners(node: Node$1 | IoElement): void;
	/**
	 * Sets `propListeners` specified as inline properties prefixed with "@".
	 * It removes existing `propListeners` that are no longer specified and it replaces the ones that changed.
	 * @param {Record<string, any>} properties - Inline properties
	 */
	applyPropListeners(properties: Record<string, any>): void;
	/**
	 * Proxy for `addEventListener` method.
	 * Adds an event listener to the node's `addedListeners` collection.
	 * If the node is an EventTarget, also registers the listener with the DOM.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	 */
	addEventListener(name: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Proxy for `removeEventListener` method.
	 * Removes an event listener from the node's `addedListeners` collection.
	 * If `listener` is not specified it removes all listeners for specified `type`.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	*/
	removeEventListener(name: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Shorthand for custom event dispatch.
	 * @param {string} name - Name of the event
	 * @param {any} detail - Event detail data
	 * @param {boolean} [bubbles] - Makes event bubble
	 * @param {Node | IoElement | EventTarget} [node] - Event target override to dispatch the event from
	 */
	dispatchEvent(name: string, detail?: any, bubbles?: boolean, node?: Node$1 | IoElement | EventTarget, path?: Array<Node$1 | IoElement | EventTarget>): void;
	/**
	 * Disconnects all event listeners and removes all references for garbage collection.
	 * Use this when node is discarded.
	 */
	dispose(): void;
}
export type CallbackFunction = (arg?: any) => void;
export type prefix$1<TKey, TPrefix extends string> = TKey extends string ? `${TPrefix}${TKey}` : never;
export type AnyEventHandler$1 = ((event: CustomEvent<any>) => void) | ((event: PointerEvent) => void) | ((event: KeyboardEvent) => void) | ((event: MouseEvent) => void) | ((event: TouchEvent) => void) | ((event: WheelEvent) => void) | ((event: InputEvent) => void) | ((event: ClipboardEvent) => void) | ((event: DragEvent) => void) | ((event: FocusEvent) => void) | ((event: TransitionEvent) => void) | ((event: AnimationEvent) => void) | ((event: ErrorEvent) => void) | ((event: Event) => void);
export type IoElementProps = NativeElementProps & {
	reactivity?: ReactivityType;
	[key: prefix$1<string, "@">]: string | AnyEventHandler$1;
};
declare class IoElement extends HTMLElement {
	static vConstructor: (arg0?: IoElementProps | Array<VDOMElement | null> | string, arg1?: Array<VDOMElement | null> | string) => VDOMElement;
	static get Style(): string;
	reactivity: ReactivityType;
	$: Record<string, HTMLElement | IoElement>;
	static get ReactiveProperties(): ReactivePropertyDefinitions;
	static get Properties(): Record<string, any>;
	static get Listeners(): ListenerDefinitions;
	readonly _protochain: ProtoChain;
	readonly _reactiveProperties: Map<string, ReactivePropertyInstance>;
	readonly _bindings: Map<string, Binding<any>>;
	readonly _changeQueue: ChangeQueue;
	readonly _eventDispatcher: EventDispatcher;
	readonly _observedObjectProperties: string[];
	readonly _observedNodeProperties: string[];
	readonly _isIoElement: boolean;
	_disposed: boolean;
	_textNode: Text;
	constructor(args?: IoElementProps);
	applyProperties(props: any, skipDispatch?: boolean): void;
	setProperties(props: any): void;
	setProperty(name: string, value: any, debounce?: boolean): void;
	init(): void;
	ready(): void;
	changed(): void;
	queue(name: string, value: any, oldValue: any): void;
	dispatchQueue(debounce?: boolean): void;
	throttle(func: CallbackFunction, arg?: any, timeout?: number): void;
	debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
	onPropertyMutated(event: CustomEvent): true | undefined;
	dispatchMutation(object?: Object | Node$1, properties?: string[]): void;
	bind<T>(name: string): Binding<T>;
	unbind(name: string): void;
	addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
	removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
	dispatch(type: string, detail?: any, bubbles?: boolean, src?: Node$1 | HTMLElement | Document | Window): void;
	dispose(): void;
	connectedCallback(): void;
	disconnectedCallback(): void;
	/**
	 * Renders DOM from virtual DOM arrays.
	 * @param {Array} vDOMElements - Array of VDOMElement[] children.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [noDispose] - Skip disposal of existing elements.
	 */
	render(vDOMElements: Array<VDOMElement | null>, host?: HTMLElement | IoElement, noDispose?: boolean): void;
	/**
	 * Recurively traverses virtual DOM elements.
	 * TODO: test element.traverse() function!
	 * @param {Array} vDOMElements - Array of VDOMElements elements.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [noDispose] - Skip disposal of existing elements.
	 */
	traverse(vChildren: VDOMElement[], host: HTMLElement | IoElement, noDispose?: boolean): void;
	/**
	* Helper function to flatten textContent into a single TextNode.
	* Update textContent via TextNode is better for layout performance.
	* TODO: Consider using normalize()? Is it the same function?
	* @param {HTMLElement} element - Element to flatten.
	*/
	_flattenTextNode(element: HTMLElement | IoElement): void;
	/**
	* Alias for HTMLElement setAttribute where falsey values remove the attribute.
	* @param {string} attr - Attribute name.
	* @param {*} value - Attribute value.
	*/
	setAttribute(attr: string, value: boolean | number | string): void;
	/**
	 * Returns a vDOM-like representation of the element with children and attributes. This feature is used in testing.
	 */
	toVDOM(): VDOMElement;
	Register(ioNodeConstructor: typeof IoElement): void;
}
/**
 * Configuration for a property of an Node class.
 * @typedef {Object} ReactivePropertyDefinition
 * @property {*} [value] The property's value. Can be any type unless `type` is specified.
 * @property {AnyConstructor} [type] Constructor function defining the property's type.
 * @property {Binding} [binding] Binding object for two-way data synchronization.
 * @property {boolean} [reflect] Whether to reflect the property to an HTML attribute.
 * @property {*} [init] Initialization arguments for constructing initial value.
 */
export type ReactivePropertyDefinition = {
	value?: any;
	type?: AnyConstructor;
	binding?: Binding<any>;
	reflect?: boolean;
	init?: any;
};
/**
 * Allows loose definition of properties by specifying only partial definitions, such as default value, type or a binding object.
 * @typedef {(string|number|boolean|Array<*>|null|undefined|AnyConstructor|Binding|ReactivePropertyDefinition)} ReactivePropertyDefinitionLoose
 */
export type ReactivePropertyDefinitionLoose = string | number | boolean | Array<any> | null | undefined | AnyConstructor | Binding<any> | ReactivePropertyDefinition;
declare class ReactiveProtoProperty {
	value?: any;
	type?: AnyConstructor;
	binding?: Binding<any>;
	reflect?: boolean;
	init?: any;
	/**
	 * Creates a property definition from various input types.
	 * @param {ReactivePropertyDefinitionLoose} def Input definition which can be:
	 * - `undefined` or `null`: Sets as value
	 * - `AnyConstructor`: Sets as type
	 * - `Binding`: Sets value from binding and stores binding reference
	 * - `ReactivePropertyDefinition`: Copies all defined fields
	 * - Other values: Sets as value
	 * @example
	 * new ReactiveProtoProperty(String) // {type: String}
	 * new ReactiveProtoProperty('hello') // {value: 'hello'}
	 * new ReactiveProtoProperty({value: 42, type: Number}) // {value: 42, type: Number}
	 * new ReactiveProtoProperty(new Binding(node, 'value')) // {value: node.value, binding: ...}
	 */
	constructor(def: ReactivePropertyDefinitionLoose);
	/**
	 * Assigns values of another ReactiveProtoProperty to itself, unless they are default values.
	 * @param {ReactiveProtoProperty} protoProp Source ReactiveProtoProperty
	 */
	assign(protoProp: ReactiveProtoProperty): void;
	/**
	 * Creates a serializable representation of the property definition.
	 * Handles special cases for better JSON serialization:
	 * - Converts object values to their constructor names
	 * - Converts function types to their names
	 * - Only includes defined fields
	 * @returns {object} A plain object suitable for JSON serialization
	 */
	toJSON(): any;
}
declare class ReactivePropertyInstance {
	value?: any;
	type?: AnyConstructor;
	binding?: Binding<any>;
	reflect: boolean;
	init?: any;
	/**
	 * Creates the property configuration object and copies values from `ReactiveProtoProperty`.
	 * @param node owner Node instance
	 * @param propDef ReactiveProtoProperty object
	 */
	constructor(node: Node$1 | IoElement, propDef: ReactiveProtoProperty);
}
export type ProtoConstructors = Array<NodeConstructor>;
export type ProtoHandlers = string[];
export type ReactiveProtoProperties = {
	[property: string]: ReactiveProtoProperty;
};
export type ProtoListeners = {
	[property: string]: ListenerDefinition[];
};
declare class ProtoChain {
	/**
	 * Array of inherited class constructors
	 */
	constructors: ProtoConstructors;
	/**
	 * Aggregated initial value for properties declared in `static get Properties()` or @Property() decorators
	*/
	properties: Record<string, any>;
	/**
	 * Aggregated reactive property definition declared in `static get ReactiveProperties()` or @ReactiveProperty() decorators
	 */
	reactiveProperties: ReactiveProtoProperties;
	/**
	 * Aggregated listener definition declared in `static get Listeners()`
	 */
	listeners: ProtoListeners;
	/**
	 * Aggregated CSS style definition declared in `static get Style()`
	 */
	style: string;
	/**
	 * Array of function names that start with "on[A-Z]" or "_on[A-Z]" for auto-binding.
	 */
	handlers: ProtoHandlers;
	/**
	 * Creates an instance of `ProtoChain` for specified class constructor.
	 * @param {NodeConstructor} ioNodeConstructor - Owner `Node` constructor.
	 */
	constructor(ioNodeConstructor: NodeConstructor);
	/**
	 * Auto-binds event handler methods (starting with 'on[A-Z]' or '_on[A-Z]') to preserve their 'this' context.
	 * NOTE: Defining handlers as arrow functions will not work because they are not defined before constructor has finished.
	 * @param {Node | IoElement} node - Target node instance
	 */
	init(node: Node$1 | IoElement): void;
	/**
	 * Adds properties defined in decorators to the properties array.
	 * @param {NodeConstructor} ioNodeConstructor - Owner `Node` constructor.
	 */
	addPropertiesFromDecorators(ioNodeConstructor: NodeConstructor): void;
	addProperties(properties?: Record<string, any>, prevHash?: string): string;
	/**
	 * Adds reactive properties defined in decorators to the properties array.
	 * @param {NodeConstructor} ioNodeConstructor - Owner `Node` constructor.
	 */
	addReactivePropertiesFromDecorators(ioNodeConstructor: NodeConstructor): void;
	/**
	 * Adds reactive properties from `static get ReactiveProperties()` to the properties array.
	 * Only process properties if they differ from superclass.
	 * This prevents 'static get ReactiveProperties()' from overriding subclass properties defined in decorators.
	 * @param {ReactivePropertyDefinitions} properties - Properties to add
	 * @param {string} prevHash - Previous properties hash
	 * @returns {string} - Updated properties hash
	 */
	addReactiveProperties(properties?: ReactivePropertyDefinitions, prevHash?: string): string;
	/**
	 * Merges or appends a listener definitions to the existing listeners array.
	 * @param {ListenerDefinitions} listenerDefs - Listener definitions to add
	 */
	addListeners(listenerDefs?: ListenerDefinitions): void;
	/**
	 * Adds a style string to the styles array.
	 * @param {string} style - Style string to add
	 */
	addStyle(style?: string): void;
	/**
	 * Adds style defined in decorators to the style string.
	 * @param {NodeConstructor} ioNodeConstructor - Owner `Node` constructor.
	 */
	addStyleFromDecorators(ioNodeConstructor: NodeConstructor): void;
	/**
	 * Adds function names that start with "on[A-Z]" or "_on[A-Z]" to the handlers array.
	 * @param {Node} proto - Prototype object to search for handlers
	 */
	addHandlers(proto: Node$1 | IoElement): void;
	/**
	 * Validates reactive property definitions in debug mode.
	 * Logs warnings for incorrect property definitions.
	 * @returns {void}
	 */
	validateReactiveProperties(): void;
}
export type AnyConstructor = new (...args: any[]) => unknown;
export type ReactivePropertyDefinitions = Record<string, ReactivePropertyDefinitionLoose>;
export type ListenerDefinitions = {
	[key: string]: ListenerDefinitionLoose;
};
export interface NodeConstructor {
	ReactiveProperties?: ReactivePropertyDefinitions;
	Properties?: Record<string, any>;
	Listeners?: ListenerDefinitions;
	Style?: string;
	name?: string;
	prototype: NodeConstructor | Object | HTMLElement;
}
export type ReactivityType = "immediate" | "throttled" | "debounced";
declare class Node$1 extends Object {
	reactivity: ReactivityType;
	static get ReactiveProperties(): ReactivePropertyDefinitions;
	static get Properties(): Record<string, any>;
	static get Listeners(): ListenerDefinitions;
	readonly _protochain: ProtoChain;
	readonly _reactiveProperties: Map<string, ReactivePropertyInstance>;
	readonly _bindings: Map<string, Binding<any>>;
	readonly _changeQueue: ChangeQueue;
	readonly _eventDispatcher: EventDispatcher;
	readonly _observedObjectProperties: string[];
	readonly _observedNodeProperties: string[];
	readonly _parents: Array<Node$1>;
	readonly _isNode: boolean;
	readonly _isIoElement: boolean;
	_disposed: boolean;
	constructor(args?: any);
	applyProperties(props: any, skipDispatch?: boolean): void;
	setProperties(props: any): void;
	setProperty(name: string, value: any, debounce?: boolean): void;
	init(): void;
	ready(): void;
	changed(): void;
	queue(name: string, value: any, oldValue: any): void;
	dispatchQueue(debounce?: boolean): void;
	throttle(func: CallbackFunction, arg?: any, timeout?: number): void;
	debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
	onPropertyMutated(event: CustomEvent): true | undefined;
	dispatchMutation(object?: Object | Node$1, properties?: string[]): void;
	bind<T>(name: string): Binding<T>;
	unbind(name: string): void;
	addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
	removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
	dispatch(type: string, detail?: any, bubbles?: boolean, src?: Node$1 | HTMLElement | Document | Window): void;
	addParent(parent: Node$1): void;
	removeParent(parent: Node$1): void;
	dispose(): void;
	Register(ioNodeConstructor: typeof Node$1): void;
}
export interface Change {
	property: string;
	value: any;
	oldValue: any;
}
export interface ChangeEvent extends Omit<CustomEvent<Change>, "target"> {
	readonly target: Node$1 | IoElement;
	readonly detail: Change;
	readonly path: Node$1[];
}
declare class ChangeQueue {
	readonly node: Node$1 | IoElement;
	readonly changes: Change[];
	dispatchedChange: boolean;
	dispatching: boolean;
	/**
	 * Creates change queue for the specified owner instance of `Node`.
	 * @param {Node} node - Owner node.
	 */
	constructor(node: Node$1 | IoElement);
	/**
	 * Adds property change payload to the queue by specifying property name, previous and the new value.
	 * If the change is already in the queue, the new value is updated in-queue.
	 * If the new value is the same as the original value, the change is removed from the queue.
	 * @param {string} property - Property name.
	 * @param {any} value Property value.
	 * @param {any} oldValue Old property value.
	 */
	queue(property: string, value: any, oldValue: any): void;
	/**
	 * Dispatches and clears the queue.
	 * For each property change in the queue:
	 *  - It executes node's `[propName]Changed(change)` change handler function if it is defined.
	 *  - It fires the `'[propName]-changed'` `ChangeEvent` from the owner node with `Change` data as `event.detail`.
	 * After all changes are dispatched it invokes `.changed()` function of the owner node instance and fires `'changed'` event.
	 */
	dispatch(): void;
	/**
	 * Clears the queue and removes the node reference for garbage collection.
	 * Use this when node queue is no longer needed.
	 */
	dispose(): void;
}
export type Properties = string[];
export type TargetProperties = WeakMap<Node$1 | IoElement, Properties>;
declare class Binding<T extends unknown> {
	readonly node: Node$1 | IoElement;
	readonly property: string;
	readonly targets: Array<Node$1 | IoElement>;
	readonly targetProperties: TargetProperties;
	/**
	 * Creates a binding object for specified source `node` and `property`.
	 * It attaches a `[propName]-changed` listener to the source node.
	 * @param {Node | IoElement} node - Source node
	 * @param {string} property - Name of the sourceproperty
	 */
	constructor(node: Node$1 | IoElement, property: string);
	set value(value: T);
	get value(): T;
	/**
	 * Adds a target node and property.
	 * Sets itself as the binding reference on the target `ReactivePropertyInstance`.
	 * Adds a `[propName]-changed` listener to the target node.
	 * @param {Node | IoElement} target - Target node
	 * @param {string} property - Target property
	 */
	addTarget(target: Node$1 | IoElement, property: string): void;
	/**
	 * Removes target node and property.
	 * If `property` is not specified, it removes all target properties.
	 * Removes binding reference from the target `ReactivePropertyInstance`.
	 * Removes `[propName]-changed` listener from the target node.
	 * @param {Node | IoElement} target - Target node
	 * @param {string} property - Target property
	 */
	removeTarget(target: Node$1 | IoElement, property?: string): void;
	/**
	 * Event handler that updates source property when one of the targets emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onTargetChanged(event: ChangeEvent): void;
	/**
	 * Event handler that updates bound properties on target nodes when source node emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onSourceChanged(event: ChangeEvent): void;
	/**
	 * Returns a list of target properties for specified target node.
	 * @param {Node | IoElement} target - Target node.
	 * @return {Properties} list of target property names.
	 */
	getTargetProperties(target: Node$1 | IoElement): Properties;
	/**
	 * Returns a JSON representation of the binding.
	 * This is required for `JSON.stringify(protoProperties)` in `ProtoChain`.
	 * @return {string} JSON representation of the binding.
	 */
	toJSON(): {
		node: string;
		property: string;
		targets: string[];
		targetProperties: Properties[];
	};
	/**
	 * Disposes the binding and removes all targets and listeners.
	 */
	dispose(): void;
}
export type Collection = {
	description: string;
	id: string;
};
declare class SimulatorState extends Node$1 {
	clientId: string;
	clientName: string;
	clientType: string;
	connectedClients: Array<any>;
	currentCollection: Collection;
	currentCollectionId: string;
	currentCollectionItems: Array<string>;
	currentScreenId: string;
	currentSearchGravity: number;
	currentSearchString: string;
	highlightedItem: any;
	highlightedItemId: string;
	highlightedItemIds: Array<string>;
	magnets: Array<any>;
	screenIds: Array<string>;
	selectedItem: any;
	selectedItemId: string;
	selectedItemIds: Array<string>;
	lastUpdated: string;
	tags: Array<string>;
	updateCounter: number;
	update(state: SimulatorState): void;
}
export type PresenceState = {
	[key: string]: Presence[];
};
export type Presence = {
	clientId: string;
	clientName: string;
	clientType: string;
	presence_ref: string;
	startTime: number;
};
export type SimulatorPresence = {
	clientId: string;
	clientName: string;
	clientType: string;
	presence_ref: string;
	shared: SimulatorState;
	startTime: number;
};
export declare class SpacetimeController extends IoElement {
	static get Style(): string;
	static supabaseUrl: string;
	static supabaseAnonKey: string;
	static clientChannelName: string;
	static clientType: string;
	clientId: string;
	clientName: string;
	supabaseClient: any;
	clientChannel: any;
	clientConnected: boolean;
	currentSimulatorId: string | null;
	simulatorState: SimulatorState;
	constructor(props: IoElementProps);
	connect(): void;
	ready(): void;
	sendPanEvent(deltaX: number, deltaY: number): void;
	sendZoomEvent(zoomDelta: number): void;
	sendSelectEvent(action: string): void;
	sendAddMagnetEvent(magnetName: string): void;
	sendDeleteMagnetEvent(magnetName: string): void;
	sendPushMagnetEvent(magnetName: string, deltaX: number, deltaZ: number): void;
	sendEventToSimulator(eventType: string, data: any): void;
	setSearchGravity(gravity: number): void;
	setupPresenceHandlers(): void;
	subscribeToChannel(): void;
	updatePresenceState(): Promise<void>;
	findLatestSimulator(presenceState: PresenceState): SimulatorPresence | null;
}

export {};
